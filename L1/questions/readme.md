### 1. Какой самый эффективный способ конкатенации строк?
strings.Builder

Пример:
```
builder := strings.Builder{}
for i := 0; i < 1000; i++ {
    builder.WriteString("aaa")
}
str := builder.String()
```
### 2. Что такое интерфейсы, как они применяются в Go?

Интерфейс - это абстрактный тип данных, определяющий множество функций, которые необходимо реализовать, чтоб тип считался
реализацией интерфейса. Используется для абстрагирования от реализации. Нужно для её простой подмены, т.е. функция принимает
вроде бы один тип данных, но на деле может принимать разные структуры с разными реализациями. Способствует простоте 
внесения изменений.

### 3. Чем отличаются RWMutex от Mutex?

RWMutex отличается от Mutex тем, что может удерживаться несколькими читателями или одним писателем. Mutex может 
удерживаться одним читателем или одним писателем. Т.е. RWMutex разрешает параллельное чтение.

### 4. Чем отличаются буферизированные и не буферизированные каналы?

При записи в небуферезированный канал горутина блокируется пока из канала не прочитают, при чтении аналогично.
При записи в буферизированный канал горутина не блокируется пока в буфере есть место, при чтении не блокируется
пока есть что читать. Размер буфера указывается при создании.

Оба канала представленны одной структурой hchan, которая хранит в себе буфер, 2 индекса для чтения и записи, списки
читателей и писателей с данными и т.д. При чтении из небуферезированного канал сразу идёт обращение в очередь
писателей за данными либо блокируется горутина в ожидании записи, при записи горутина ставится в очередь либо сразу
отдаёт данные, если есть кому прочитать.
При записи в буферизированный канал данные попадают в буффер и передвигается индекс записи, при чтении данные бурутся
из буфера и передвигается индекс чтения. Буфер кольцевой. Если буфер полон или нет данных горотуны блокируются и поподают
в соответсвующие очереди. Очередь представленна двусвязным списком с элементами типа sudog, хранящих дескриптор горутины
и данные для записи или адрес для чтения, в зависимости от операции. Для отличния у канала есть переменная хранящая размер
буфера.

### 5. Какой размер у структуры struct{}{}?
**0** проверил через unsafe.Sizeof

### 6. Есть ли в Go перегрузка методов или операторов?

В go нет перегрузок.

Для перегрузки функции и методов можно использовать дженерики.
Для переопределения методов можно воспользоваться встраиванием. Если имена метод "родительской" и "дочерней" структур
совпадают, то предпочтение отдаётся дочернему методу, при условии использования дочерней сущности. Но эти методы
никак не связаны, т.е. могут иметь разную семантику.
Операторы не переопределяются.

### 7. В какой последовательности будут выведены элементы map[int]int?

В случайном

### 8. В чем разница make и new?

new() просто алоцирует объект и возвращает указатель на него. Работает для всех типов. Значение самого объекта будет
нулевым

make() не только алоцирует, но и инициализирует объекты. Работает только для срезов, каналов и мап. Суть работы именно
с этими типами заключается в том, что под капотом они содержат указатели, которые нужно проинициализировать. В случае
вызова new() указатели будут иметь значение nil.

### 9. Сколько существует способов задать переменную типа slice или map?

Через {}
```
s := []int{1, 2, 3}
m := map[int]int{
    1: 2,
    3: 4,
}
```
Через make
```
s := make([]int, 10)
m := make(map[int]int)
```

Мб сюда можно отнести оператор [:] и append для slice.

### 10. Что выведет данная программа и почему?
```
func update(p *int) {
	b := 2
	p = &b
}

func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p)
	update(p)
	fmt.Println(*p)
}
```
Вывод
```
1
1
```
Так как update принимает значение указателя, а не указатель на указатель, соответственно в функции меняется локальная
копия указателя.

### 11. Что выведет данная программа и почему?
```
func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}
```

Вызовет deadlock т.к. WaitGroup передаётся в замыкание по значению, т.е. функция работает с его копией, а не конкретно
с ним. Соответственно счётчик WaitGroup инкриминируется, но никогда не декрементируется, это приводит к тому, что wait
никогда не сработает и программа навечно встанет (deadlock).

Если передать WaitGroup нормально (по указателю), то выведутся числа от 0 до 4 в случайной порядке и после строка "exit"

### 12. Что выведет данная программа и почему?
```
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
Вывод
```
0
```
Так как внутри фигурных скобок образуется новая области видимости, где создаётся **другая** переменная n (перекрывает
n из main).  В разных областях видимости имена переменных могут совпадать.

### 13. Что выведет данная программа и почему?
``` 
func someAction(v []int8, b int8) {
	v[0] = 100
	v = append(v, b)
}

func main() {
	var a = []int8{1, 2, 3, 4, 5}
	someAction(a, 6)
	fmt.Println(a)
}
```
Вывод
```
[100 2 3 4 5]
```
Слайс представляет собой структуру хранящую буфер, размер и ёмкость. Первый элемент поменялся т.к. в функцию по сути
передаются указатель на буфер. А вот размер его не изменился т.к. append возвращает новый дескриптор с изменёнными 
размером и ёмкостью, а в main старый дескриптор(тип slice). А так вообще произошла переалокация, т.к. не хватало 
ёмкости на новый элемент.

### 14. Что выведет данная программа и почему?
``` 
func main() {
	slice := []string{"a", "a"}

	func(slice []string) {
		slice = append(slice, "a")
		slice[0] = "b"
		slice[1] = "b"
		fmt.Print(slice)
	}(slice)
	fmt.Print(slice)
}
```
Вывод
```
[b b a][a a]
```
Тут уже и значения изначального среза не изменятся т.к. вставка происходит в новый слайс после переалокации. Если бы
ёмкость была равна 3, то в замыкании велась бы вставка просто с лайс с новым дескриптором, который ссылался бы на старый
буфер, не было бы переалокации.



