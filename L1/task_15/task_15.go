package main

import (
	"bytes"
	"math/rand"
)

var justString string

// просто заглушка, скорее всего функция должна создавать строку размером n
func createHugeString(n int) string {
	res := ""
	buff := bytes.NewBufferString(res)

	for i := 0; i < n; i++ {
		buff.WriteByte(byte(rand.Intn(254)))
	}

	return buff.String()
}

// говорю о слайсах т.к. строка это срез байт
func someFunc() {
	// кроме того, что большая строка занимает много места в памяти, так это ещё и непрерывный кусок
	// это "брусок" и так не просто алоцировать (найти подходящее место), а тем более проблемно переалоцировать при расширении
	v := createHugeString(1 << 10)
	// алоцируем строку длинной в 1 << 10 а используем первые 100 элементов, это нелогично
	// оператор [:] не производит глубокого копирования (просто создаётся новый слайс и в него копируется указатель на массив),
	//т.е. новый слайс будет ссылаться на старый. Основная проблема заключается в том, что пока сущ вторичный срез,
	//ссылающийся на первичный, первичный не будет выгружен из памяти
	// в итоге пользуемся строкой из 100 символов, а храним строку длиной 1 << 10
	// вроде как глобальные перемнные не освобождаются gc, соответсвенно не освобождается и то, на что они ссылаются
	// мб эта огромная строка будет сущ в течении всего времени работы программы
	justString = v[:100]
	// да и вообще лучше не использовать глобальные переменные, они создают побочные эффекты
}

func someFuncCorrected() string {
	// 1) сразу создаём строку нужного размера, используем столько памяти, сколько необходимо
	// 2) возврат строки и присваивание её не глобальной переменной позволит gc удалить её, как только перестанет быть нужна
	// 3) нет глоб переменной => нет побочных эффектов (если других нет)
	return createHugeString(100)
}

func main() {
	someFunc()
}
